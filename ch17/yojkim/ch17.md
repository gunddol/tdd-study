### 17. Money 회고



##### 다음에 할 일은 무엇인가?

- 일반적으로는 클래스에서 인터페이스로 바뀌는 방향이 많다.
- 시스템이 클 수록 건드리는 부분들에 대한 테스트가 견고해야한다.
- 다음에 할일은 무엇인가에 관련된 또 다른 질문은 어떤 테스트들이 추가로 더 필요할까이다.
- 때로는, 실패해야하는 테스트가 성공해버리는 경우가 있는데 그런 경우에도 원인을 찾아내야한다.
- 할일 목록이 비워질 때, 설계한 것을 되돌아보기 아주 좋은 타이밍이다.
  - 말과 개념이 서로 잘 통하는가?
  - 현재의 설계로는 제거하기 힘든 중복이 있는가?



##### 메타포

> '통화가 다른 금전'에 대해 워드 커닝엄이 사용한 메타포는 '벡터'였다.

- 모든 Money에 관련된 메타포는 Money의 집합이 딱 떨어지는 숫자로 된다는 걸 암시한다.



##### 코드 메트릭스

- 코드와 테스트 사이에 **대략** 비슷한 양의 함수와 줄이 있다.
- 테스트 코드의 줄 수는 공통된 테스트 fixture를 뽑아냄으로서 줄일 수 있다. 그러나, 모델 코드와 테스트 코드 사이의 대략적인 줄 수 의 비율은 비슷하게 유지될 것이다.
- `회기성 복잡도(cyclomatic complexity)`는 기존의 `흐름 복잡도(flow complexity)`와 동일하다. 테스트 코드에 분기나 반복문이 전혀 없기 때문에 테스트 복잡도는 1이다.



##### 프로세스

- TDD의 주기는 다음과 같다.
  - 작은 테스트를 추가한다.
  - 모든 테스트를 실행하고, **실패하는 것**을 확인한다.
  - 코드에 변화를 준다.
  - 모든 테스트를 실행하고, 성공하는 것을 확인한다.
  - 중복 제거를 위한 **리팩토링**을 실시한다.



##### 테스트의 질

- 테스트의 수명은 시스템의 수명과 같이할만큼 유용하다.
- 그러나 이러한 테스트들이 다음과 같은 테스트를 대체할 수 있을거라고 생각해서는 **안된다.**
  - 성능 테스트
  - 스트레스 테스트
  - 사용성 테스트
- 만약 테스트 주도 코드의 결함 밀도가 매우 낮다면 테스팅의 역할은 시스템이 어떠한 역할을 가져야한다고 기능을 정의하는 사람들과 실제로 그것을 구현하는 사람들 간의 의사소통 쪽의 방향으로 좀 더 치중될 것이다.
- `테스트 커버리지 수치`란 `(프로그램의 서로 다른 경우를 테스트하는 테스트 수) / (테스팅이 필요한 경우의 수)` 이다.
- `테스트 커버리지`를 향상시키는 한 가지 방법은 더욱 많은 테스트를 작성하는 것이다.
- `테스트 커버리지`를 향상시키는 다른 방법은 로직을 단순화하는 것이다.
- `리팩토링` 단계가 종종 위와 같은 효과를 불러온다.



##### 최종 검토

- 테스트를 확실히 돌아가게 만드는 세 가지 접근법
  - 가짜로 구현하기
  - 삼각 측량법
  - 명백하게 구현하기
- 설계를 주도하기 위한 방법
  - 테스트 코드와 실제 코드 사이의 중복을 제거하기
- 어려운 문제에 직면했을 경우 속도를 줄이고 상황이 좋은 경우 속도를 높일 수 있는 능력