## 17. Money 회고
   
> 다음에 할일은 무엇인가
- 코드가 끝난 것은 아님  
  => **Sum.plus()** 와 **Money.plus()** 사이에 중복된 것이 많은데 **Expression** 인터페이스를 클래스로 바꾸어 공통된 코드는 담는 그릇으로 사용한다면 더 많은 중복 제거를 할 수 있음
- 할일 목록이 비었을 때가 검토하기에 가장 적절한 시기  
  => 모든 구현이 끝났으므로 사용자의 입장에서 프로그램을 테스트해보고 실제 상황과 설계 상의 의도가 잘 맞는지 확인, 중복된 것이 혹여나 있는지, 있다면 제거할 수 있는지 파악해볼 것

> 메타포
- **Expression** 메타포가 나오기까지의 과정  
  => **MoneySum** -> **MoneyBag** -> **Wallet**
- 식의 동류항 정리하듯이 같은 통화는 합쳐서 나타낼 수 있는데 이는 중복성 제거의 탁월한 결과  
  => 예를 들면 **'2USD + 5CHF + 3USD'** 는 **'5USD + 5CHF'** 로 합쳐서 나타낼 수 있음

> 코드 메트릭스
- 실제 코드와 테스트 코드를 비교하여 대략적인 비율을 확인할 수 있음
- 함수의 개수와 코드의 줄 수는 실제 코드와 테스트 코드가 서로 비슷함
- 테스트 코드는 분기와 반복문이 전혀 없기에 복잡도가 1이고, 실제 코드 또한 분기 및 반복문 대신 다형성을 이용한 클래스와 객체로 대부분 구현하였기에 복잡도가 1에 가까움
- 함수당 줄 수는 크게 의미는 없음
  
> 프로세스
- TDD 주기  
  1. 작은 테스트를 추가
  2. 모든 테스트를 실행하고, 실패하는 것을 확인
  3. 코드에 변화를 줌
  4. 모든 테스트를 실행하고, 성공하는 것을 확인
  5. 중복을 제거하기 위해 리팩토링
- 테스트를 통과하기 위해 스텁을 구현하고 끊임없이 리팩토링하는 과정이 TDD의 핵심
  
> 테스트의 질
- TDD에서 작성한 테스트는 시스템의 수명이 다할 때까지 함께 유지되어야 할 만큼 확실히 유용함
- **테스트 커버리지** : 테스트 수를 테스팅이 필요한 경우의 수로 나눈 값  
  => 전문 테스터들은 테스트 커버리지가 엄청나게 높은데, 이는 분모에 해당하는 테스팅이 필요한 경우의 수를 감소시키는, 즉 로직을 단순화하는 방향으로 전문적인 역량을 가졌기 때문
  => 프로그램의 로직을 단순화하는 것은 중복 제거의 일환이며, 이는 곧 리팩토링의 주된 목적
  => 테스트는 그대로 두고 코드를 줄여서 적은 테스트가 다양한 경우를 다루게끔 하는 것이 궁극적인 목표

> 최종 목표
1. 세 가지 접근법 : 가짜로 구현하기, 삼각측량법, 명백하게 구현하기
2. 테스트 코드와 실제 코드 사이의 중복을 제거
3. 테스트 사이의 간격을 상황에 맞게 조절하는 능력